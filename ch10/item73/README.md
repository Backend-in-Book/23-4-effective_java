---

marp: true

---

# 아이템 73
# 추상화 수준에 맞는 예외를 던지라

---

# 예외

* 메서드가 저수준 예외를 처리하지 않으면 문제가 발생한다.
    * 수행하려는 일과 관련 없는 예외가 발생한다.
    * 구현 방식을 변경하면 다른 예외가 발생하여 기존 클라이언트 프로그램이 깨질 수 있다.

---

# 예외 번역(Exception Translation)

앞에서의 문제를 해결하기 위한 방법으로는 예외 번역이 있다.

* 예외번역 : 상위 계층에서 저수준 예외를 잡아 상위 계층의 추상화 수준에 맞는 예외로 변경해줌

~~~java
try{
    ... // 저수준 추상화를 이용한다.
} catch( LowerLevelException e ){
    // 추상화 수준에 맞게 번역한다.
    throw new HighLevelException( ... );
}
~~~

---

# 에외 연쇄(Exception Chaining)

* 앞에서의 예외 번역에서 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는것이 좋다.
* 별도의 접근자 메서드(Throwable의 getCause 메서드)를 통해 필요하면 저수준 예외를 꺼내 볼 수 있다.

~~~java
try{
    ... // 저수준 추상화를 이용한다.
} catch( LowerLevelException cause ){
    // 저수준 예외를 고수준 예외에 실어 보낸다.
    throw new HighLevelException(cause);
}
~~~

---

# 에외 연쇄(Exception Chaining)

* 대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.
    * 그렇지 않은 예외는 Throwable의 initCause 메서드를 통해 원인을 직접 설정할 수 있다.
* 예외를 전파하는 것보다 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 안된다.
    * 가능하다면 저수준 메서드가 성공하도록 하여 예외가 발생하지 않도록 하는 것이 최선이다.
    * 상위 계층 메서드의 매개변수 값을 미리 검사하고 아래 계층에 건네주는 방법도 있다.

---

# 차선책

* 아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 API 호출자에게 까지 전파하지 않는 방법이 있다.
    * 이런경우 예외를 log로 남겨 기록하고, 후에 프로그래머가 로그를 분석해서 추가 조치를 취할 수 있게 해준다.

---

# 정리

* 아래 계층의 예외를 상위 계층에 그대로 보내기 곤란하다면 예외 번역을 사용하라.
* 예외 번역을 사용할 때 예외 연쇠를 같이 사용한다면 근본 원인도 함께 알려주어 오류를 분석하기 좋다.