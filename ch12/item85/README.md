---
marp: true
backgroundColor: #FFFFF0
theme: gaia
_class: lead
---

# 자바 직렬화의 대안을 찾으라

### 최 혁

---

## 직렬화

__데이터를 다른 형태의 데이터(포맷)으로 변환하는 과정__

__직렬화를 사용하는 이유__
1. 만약 참조값을 그대로 저장하면 통신하는 대상엔 의미없는 주소값이 전달되기에
2. 자바 외부 시스템(메모리, DB, 네트워크)로 전송하기 위해

__자바 직렬화:  자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 스트림 형태로 변환하는 과정__

---

## 자바 직렬화를 잘 사용하지 않는 이유

__뒤에서 살펴보겠지만, 자바 직렬화는 많은 취약점이 존재한다. 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘(cross-platform structured-data representation)도 많기에 자바 직렬화는 잘 사용하지 않는다!__

1. CVS: 콤마로 데이터를 구분한다. opencvs 라이브러리고 쉽게 변환 가능
2. JSON: 브라우저와 서버의 통신용으로 만들졌고, 텍스트 기반이다.

위 포맷 형식으로 변환하는 라이브러리를 이용하면 쉽게 직렬화할 수 있다.(opencsv, Jackson, GSON)

---

## 그럼에도 자바 직렬화가 사용되는 경우

1. __서블릿 세션__
서블릿 기반의 WAS는 대부분 세션의 자바 직렬화를 지원하고 있다. 만약 세션을 서블릿 메모리가 아닌 파일이나 세션 클러스터링, DB를 저장하는 옵션 등을 선택하게 된다면 세션 자체가 직렬화되어 저장되어 전달되기에 Serializable을 구현해야 한다.

2. __캐시__
캐시할 데이터를 자바 직렬화를 사용하여 저장하기도 한다고 한다..(redis를 사용해보진 않았지만 조금 찾아봐도 자바 직렬화로 저장하지 않는거 같은데..)

3. __자바 RMI__
전달할 메시지(객체)를 직렬화해야 사용할 수 있다.

---

## 자바 직렬화의 취약점

1. ObjectInputStream의 readObject 메서드를 호출하면서 객체 그래프가 역직렬화하는 구조가 문제이다.

바이트 스트림을 역직렬화하는 과정에서 readObject 메서드는 역직렬화할 객체 타입의 모든 메서드를 수행할 수 있기에 그 타입들의 전체 코드가 공격 받을 수 있다.

2. 역직렬화에 시간이 오래 걸리는 짧은 스트림을 보내는 서비스 거부 공격에 쉽게 노출될 수 있다.

역직렬화할 때 HashSet같이 원소의 해시코드를 계산해야 하는 과정이 반복문에 의해 깊이 만들어진다면 처리과정이 수없이 늘어난다.

---

## 결론

__직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다!__

__만약 직렬화를 사용한다면 자바 직렬화 말고 JSON, CVS같은 다른 포멧으로 보내자!__

__만약 자바 직렬화를 사용하게 된다면 java.io.ObjectInputFilter를 사용하자!__
(데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이다. 클래스 단위로 특정 클래스를 받아들이거나 거부할 수 있다.)

